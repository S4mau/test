<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Literature Quiz — Single Question / Reveal / Second Chance</title>
<style>
:root{
  --bg:#071021; --card:#0f1724; --muted:#c8d0df; --accent:#ffb703;
  --ok:#1e693f; --bad:#a32727;
}
*{box-sizing:border-box}
body{
  margin:0; min-height:100vh; font-family:Inter,system-ui,Arial;
  background:linear-gradient(180deg,#071021 0%,#1a1730 100%);
  color:var(--muted);
  display:flex; align-items:center; justify-content:center; padding:18px;
  transition: background .7s ease, color .45s ease;
}
.wrap{
  width:min(1100px,96vw);
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
  border-radius:12px; padding:18px;
  box-shadow:0 12px 40px rgba(2,6,23,0.6);
  border:1px solid rgba(255,255,255,0.03);
}

/* header */
.header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:14px }
.header h1{ font-size:1.05rem; margin:0; color:#fff }
.header .stats{ display:flex; gap:10px; align-items:center }
.stat{ background:rgba(255,255,255,0.03); padding:6px 10px; border-radius:8px; font-weight:800; color:#fff }

/* answers - single big card */
.answers{ display:block; }
.qcard{
  background:var(--card);
  padding:22px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.04);
  margin-bottom:12px;
  min-height:220px;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.qhead{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; color:#eaf2ff; font-weight:800; }
.qnum{ font-size:1.05rem; }
.qtext{ font-size:1.12rem; line-height:1.4; color:#f7fbff; margin-top:8px; }

/* larger options */
.opts{ display:flex; flex-direction:column; gap:10px; margin-top:6px; }
.opt{ padding:12px 14px; border-radius:10px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); cursor:pointer; text-align:left; font-weight:700; color:var(--muted); transition: transform .12s, box-shadow .2s; }
.opt:hover{ transform: translateY(-3px) }
.opt.selected{ outline:3px solid rgba(255,183,3,0.12); background:rgba(255,183,3,0.09); color:#fff }
.opt.correct{ background:var(--ok); color:#fff; box-shadow:0 8px 26px rgba(30,105,63,0.14) }
.opt.wrong{ background:var(--bad); color:#fff; box-shadow:0 8px 26px rgba(163,39,39,0.14) }

/* text input */
/* bigger, multiline input (textarea) */
.inputText {
  width: 100%;
  min-height: 120px;      /* initial height */
  max-height: 44vh;       /* prevents it from growing too large on tall screens */
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.06);
  background: rgba(255,255,255,0.02);
  color: var(--muted);
  font-family: inherit;
  font-size: 1rem;
  line-height: 1.45;
  resize: vertical;       /* user can drag to make it taller */
  overflow: auto;         /* show scrollbar when needed */
  box-shadow: none;
  transition: box-shadow .18s, border-color .18s;
}

/* slightly bigger focus state so it's obvious */
.inputText:focus {
  outline: none;
  box-shadow: 0 6px 18px rgba(255,183,3,0.06);
  border-color: rgba(255,183,3,0.12);
}


/* reveal badge for text */
.textResult.badge { margin-left: 8px; padding: 8px 10px; border-radius: 8px; font-weight: 800; font-size:0.95rem; }
.textResult.correct { background: #1e693f; color: #fff; }
.textResult.wrong   { background: #a32727; color: #fff; }

/* controls */
.controls{ display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:8px }
.btnPrimary{ background:linear-gradient(90deg,#ffb703,#ff9800); color:#111; font-weight:900; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; }
.btnGhost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:8px 12px; border-radius:10px; cursor:pointer }
.btnSmall{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:8px; cursor:pointer }

/* final box */
.finalBox{ text-align:center; padding:12px; border-radius:8px; margin-top:12px; background:rgba(255,255,255,0.02) }

/* second chance visuals persist */
body.second-chance { background: linear-gradient(120deg,#0a0710 0%, #120417 35%, #0c0310 100%); color:#f6eefc; }
.wrap.second-chance { background: linear-gradient(180deg, rgba(14,6,18,0.92), rgba(8,3,12,0.92)); border-color: rgba(191,70,172,0.06); }

/* cinematic overlay */
#cinematic-overlay{ position: fixed; inset: 0; z-index: 99999; pointer-events:none; display:flex; align-items:center; justify-content:center; }
.cine-bar { position:absolute; left: 0; right:0; height:12vh; background: rgba(6,4,6,0.94); transform: translateY(-120%); }
.cine-bar.bottom { bottom:0; transform: translateY(120%); }
.cine-title { font-weight:900; color:#fef6ff; font-size: clamp(28px, 6vw, 48px); text-shadow:0 10px 30px rgba(0,0,0,0.6); transform: translateY(30px); opacity:0; }

/* accessibility */
.opt:focus { outline: 2px dashed rgba(255,255,255,0.06); outline-offset: 4px; }

@media (max-width:880px){
  .qcard{ padding:16px; min-height:200px; }
}
</style>
</head>
<body>

<div class="wrap" id="wrap">
  <div class="header">
    <h1>Literature Quiz — Single Question (Second Chance)</h1>
    <div class="stats">
      <div class="stat">Round: <span id="roundIdx">1</span>/<span id="roundTotal">1</span></div>
      <div class="stat">Score: <span id="accScore">0</span> / <span id="poolTotal">0</span></div>
    </div>
  </div>

  <section>
    <div class="answers" id="answers"></div>

    <div class="controls">
      <div class="small">Answered: <span id="selectedCount">0</span> / <span id="perRound">1</span></div>
      <div style="display:flex; gap:8px;">
        <button class="btnGhost" id="retrySame">Retry</button>
        <button class="btnGhost" id="reshuffleAll">Reshuffle</button>
        <button class="btnGhost" id="revealBtn" style="display:none">Reveal Answer</button>
        <button class="btnPrimary" id="confirmBtn" disabled>Confirm</button>
        <button class="btnPrimary" id="nextBtnRound" style="display:none">Next ▶</button>
      </div>
    </div>

    <div id="finalBoxHolder"></div>
  </section>
</div>

<!-- sounds (optional) -->
<audio id="sClick" src="assets/sounds/sfx_click.ogg" preload="auto"></audio>
<audio id="sCorrect" src="assets/sounds/Correct-1.ogg" preload="auto"></audio>
<audio id="sWrong" src="assets/sounds/Incorrect-1.ogg" preload="auto"></audio>

<script>
/* CONFIG */
const PER_ROUND = 1;      // one question per round
const TOTAL_Q = 3;       // update to your total count

/* POOL format:
  - number: unique question id
  - type: 'mcq' or 'text'
  - question: the text prompt
  - choices: array of strings (for mcq) in A,B,C,D order
  - correct: for mcq -> 'A'|'B'|'C'|'D'; for text -> correct text string
*/
const POOL = [
  //{ number: 15, type: 'mcq', question: 'Which poet wrote "The Waste Land  Which poet wrote "The Waste Land Which poet wrote "The Waste Land"?', choices:['T.S. Eliot','W.B. Yeats','Ezra Pound','Walt Whitman'], correct: 'A' },

  //Ptbd
 { number: 1, type: 'text', question: 'Tự sự Ptbd', correct: 'Kể chuyện, trình bày sự việc theo trình tự.' },
  { number: 2, type: 'text', question: 'Miêu tả Ptbd', correct: 'Tái hiện hình ảnh, cảnh vật, con người bằng ngôn ngữ.' },
  { number: 3, type: 'text', question: 'Biểu cảm Ptbd', correct: 'Bộc lộ cảm xúc, tâm trạng, tình cảm.' },
  { number: 4, type: 'text', question: 'Nghị luận Ptbd', correct: 'Nêu ý kiến, lập luận, thuyết phục người đọc.' },
 

  //bptt
  { number: 6, type: 'text', question: 'So sánh bptt', correct: 'So sánh hai sự vật, hiện tượng để làm nổi bật đặc điểm.' },
  { number: 7, type: 'text', question: 'Ẩn dụ bptt', correct: 'Gọi tên một sự vật, hiện tượng bằng một sự vật, hiện tượng khác để gợi ý nghĩa sâu hơn.' },
  { number: 8, type: 'text', question: 'Hoán dụ bptt', correct: 'Lấy một sự vật, hiện tượng liên quan để thay cho sự vật, hiện tượng cần nói.' },
  { number: 9, type: 'text', question: 'Nhân hóa bptt', correct: 'Gán đặc điểm, hành động của con người cho vật, hiện tượng, sự vật.' },
  { number: 10, type: 'text', question: 'Nói quá bptt', correct: 'Phóng đại sự vật, hiện tượng vượt quá thực tế để nhấn mạnh.' },
  { number: 11, type: 'text', question: 'Nói giảm, nói tránh bptt', correct: 'Dùng cách nói nhẹ, tránh trực tiếp để làm dịu, giảm mức độ.' },
  { number: 12, type: 'text', question: 'Liệt kê bptt', correct: 'Xếp nhiều sự vật, hiện tượng, ý tưởng nối tiếp nhau để nhấn mạnh hoặc làm rõ nội dung.' },
  { number: 13, type: 'text', question: 'Câu hỏi tu từ bptt', correct: 'Đặt câu hỏi mà không cần người nghe trả lời, nhằm nhấn mạnh hoặc gợi suy nghĩ.' },
  { number: 14, type: 'text', question: 'Đối lập / Tương phản bptt', correct: 'Đặt hai sự vật, hiện tượng trái ngược nhau để làm nổi bật đặc điểm hoặc ý nghĩa.' },

  //The tho
   { number: 15, type: 'text', question: 'Thơ lục bát', correct: 'Gồm 6 và 8 chữ' },
  { number: 16, type: 'text', question: 'Thơ song thất lục bát', correct: 'Gồm 7-7-6-8 chữ' },
  { number: 17, type: 'text', question: 'Thơ ngũ ngôn', correct: 'Mỗi câu 5 chữ' },
  { number: 18, type: 'text', question: 'Thơ thất ngôn', correct: 'Mỗi câu 7 chữ.' },
  { number: 19, type: 'text', question: 'Thất ngôn bát cú Đường luật', correct: '8 câu, 7 chữ' },
  { number: 20, type: 'text', question: 'Thất ngôn tứ tuyệt', correct: '4 câu, 7 chữ, ngắn gọn và cô đọng.' },
  { number: 21, type: 'text', question: 'Thơ tự do', correct: 'Không cố định số chữ, câu, vần; linh hoạt, hiện đại.' }

];

/* stable uid */
POOL.forEach(q => q._uid = `${q.number}`);

/* state */
let shuffled = [];
let batches = [];
let currentBatchIndex = 0;
let selections = {}; // keyed by uid
let revealed = false;
let accScore = 0;
let viewIndex = 1; // not used (kept for compatibility)

/* second chance */
let secondChanceMode = false;
let mainWrongPool = [];
let secondChancePool = [];

/* DOM */
const answersEl = document.getElementById('answers');
const selectedCountEl = document.getElementById('selectedCount');
const confirmBtn = document.getElementById('confirmBtn');
const nextBtnRound = document.getElementById('nextBtnRound');
const retrySameBtn = document.getElementById('retrySame');
const reshuffleAllBtn = document.getElementById('reshuffleAll');
const roundIdxEl = document.getElementById('roundIdx');
const roundTotalEl = document.getElementById('roundTotal');
const accScoreEl = document.getElementById('accScore');
const poolTotalEl = document.getElementById('poolTotal');
const perRoundEl = document.getElementById('perRound');
const finalBoxHolder = document.getElementById('finalBoxHolder');
const wrapEl = document.getElementById('wrap');
const revealBtn = document.getElementById('revealBtn');

const sClick = document.getElementById('sClick');
const sCorrect = document.getElementById('sCorrect');
const sWrong = document.getElementById('sWrong');

function play(el){ try{ el && el.currentTime===0 && el.play(); if(el && el.currentTime !== 0){ el.currentTime=0; el.play(); } }catch(e){} }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

/* prepare batches */
function prepareFromPool(poolArr, reshuffle=true){
  poolTotalEl.textContent = POOL.length;
  shuffled = [...poolArr];
  if(reshuffle) shuffle(shuffled);
  batches = [];
  for(let i=0;i<shuffled.length;i+=PER_ROUND) batches.push(shuffled.slice(i, i+PER_ROUND));
  roundTotalEl.textContent = batches.length || 1;
  currentBatchIndex = 0;
}

/* initial */
function prepareMain(){
  accScore = 0;
  accScoreEl.textContent = accScore;
  mainWrongPool = [];
  secondChanceMode = false;
  wrapEl.classList.remove('second-chance','intro');
  document.body.classList.remove('second-chance');
  prepareFromPool(POOL, true);
}

/* render single (or batch of size 1) */
function renderBatch(){
  finalBoxHolder.innerHTML = '';
  revealed = false;
  selections = {};
  answersEl.innerHTML = '';

  if(!batches || batches.length===0){
    finalBoxHolder.innerHTML = `<div class="finalBox"><h3>No questions in this pool.</h3></div>`;
    return;
  }

  const batch = batches[currentBatchIndex];
  roundIdxEl.textContent = currentBatchIndex + 1;
  perRoundEl.textContent = batch.length;

  // display single card(s)
  batch.forEach(item => {
    const uid = item._uid || `${item.number}`;
    const card = document.createElement('div');
    card.className = 'qcard';
    card.dataset.uid = uid;

    // header + question text
    const qhead = document.createElement('div');
    qhead.className = 'qhead';
    qhead.innerHTML = `<div class="qnum">Q${item.number}</div>`;
    const qtext = document.createElement('div');
    qtext.className = 'qtext';
    qtext.textContent = item.question || `Question ${item.number} — write text in POOL`;
    card.appendChild(qhead);
    card.appendChild(qtext);

    // answers area
    if(item.type === 'text'){
      // textarea for long answers
      const textarea = document.createElement('textarea');
      textarea.className = 'inputText';
      textarea.placeholder = 'Type answer...';
      textarea.rows = 5;
      textarea.addEventListener('input', ()=> {
        if(revealed) return;
        const val = textarea.value.trim();
        if(val.length>0) selections[uid] = val;
        else delete selections[uid];
        updateSelectionState();
      });
      card.appendChild(textarea); // <-- append the textarea (was wrong in original)
    } else if(item.type === 'mcq'){
      const opts = document.createElement('div');
      opts.className = 'opts';
      const labels = ['A','B','C','D'];
      const choices = item.choices && item.choices.length ? item.choices : ['A','B','C','D'];
      labels.forEach((lab, idx) => {
        const b = document.createElement('div');
        b.className = 'opt';
        b.tabIndex = 0;
        const text = choices[idx] ? `${lab}. ${choices[idx]}` : `${lab}`;
        b.textContent = text;
        b.dataset.letter = lab;
        b.addEventListener('click', () => {
          if(revealed) return;
          Array.from(opts.children).forEach(ch=> ch.classList.remove('selected'));
          b.classList.add('selected');
          selections[uid] = lab;
          play(sClick);
          updateSelectionState();
        });
        b.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); b.click(); } });
        opts.appendChild(b);
      });
      card.appendChild(opts); // <-- append options (was incorrectly appending textarea)
    } else {
      // unsupported type (we removed true/false)
      const note = document.createElement('div');
      note.className = 'note';
      note.textContent = 'Unsupported question type';
      card.appendChild(note); // <-- don't append textarea here
    }

    // per-card Reveal button
    const ctrlRow = document.createElement('div');
    ctrlRow.style.display='flex';
    ctrlRow.style.justifyContent='flex-end';
    ctrlRow.style.marginTop='6px';
    const revealLocal = document.createElement('button');
    revealLocal.className = 'btnSmall';
    revealLocal.textContent = 'Reveal Answer';
    revealLocal.addEventListener('click', ()=> revealAnswerForCard(uid, item, card));
    ctrlRow.appendChild(revealLocal);
    card.appendChild(ctrlRow);

    answersEl.appendChild(card);
  });

  // global reveal button
  revealBtn.style.display = 'inline-block';
  revealBtn.onclick = ()=> {
    if(revealed) return;
    const batch = batches[currentBatchIndex];
    batch.forEach(it => {
      const uid = it._uid || `${it.number}`;
      const card = answersEl.querySelector(`.qcard[data-uid="${uid}"]`);
      if(card) revealAnswerForCard(uid, it, card);
    });
  };

  updateSelectionState();
  nextBtnRound.style.display = 'none';
  confirmBtn.disabled = true;
}

/* update selection counter + confirm enable */
function updateSelectionState(){
  const answered = Object.keys(selections).length;
  selectedCountEl.textContent = answered;
  const need = batches[currentBatchIndex].length;
  confirmBtn.disabled = (answered < need) || revealed;
}

/* ---------- Replace existing revealAnswerForCard & global reveal handler with this code ---------- */

/**
 * Show the reveal UI for a single card (does NOT change scoring).
 * Only mark "wrong" for MCQ if the user actually selected something (selections[uid] exists).
 */
function showRevealForCard(uid, item, card){
  if(!card) return;
  // don't allow revealing/hiding after final confirm lock
  if(revealed) {
    // revealed === true means Confirm has been pressed for the whole batch; keep it locked
    return;
  }

  // mark card as revealed
  card.dataset.revealed = 'true';

  if(item.type === 'mcq'){
    const opts = card.querySelectorAll('.opt');
    const chosen = selections[uid]; // may be undefined
    opts.forEach(optEl => {
      const letter = optEl.dataset.letter;
      if(letter === item.correct) optEl.classList.add('correct');
      // only mark wrong if the user actually chose something and it differs
      if(typeof chosen !== 'undefined' && chosen !== null && letter === chosen && letter !== item.correct){
        optEl.classList.add('wrong');
      }
      // while revealed, prevent changing
      optEl.style.pointerEvents = 'none';
    });
  } else if(item.type === 'text'){
    // remove prior result nodes if any
    card.querySelectorAll('.textResult').forEach(n=>n.remove());
    // show the correct answer always
    const input = card.querySelector('.inputText');
    const correct = (item.correct||'').toString().trim();
    const chosen = selections[uid];
    // only show a Wrong badge if the user entered something and it's wrong
    if(input){
      if(typeof chosen !== 'undefined' && chosen !== null && chosen.toString().trim().length > 0){
        const ans = chosen.toString().trim().toLowerCase();
        const ok = ans === correct.toLowerCase();
        const badge = document.createElement('span');
        badge.className = 'textResult badge ' + (ok ? 'correct' : 'wrong');
        badge.textContent = ok ? 'Correct' : 'Wrong';
        input.insertAdjacentElement('afterend', badge);
      }
      // always show the correct answer text below
      const reveal = document.createElement('div');
      reveal.className = 'note reveal-answer';
      reveal.style.marginTop = '8px';
      reveal.innerHTML = `<strong>Answer: </strong><span class="badge">${correct}</span>`;
      card.appendChild(reveal);
      // disable input while revealed (optional)
      input.disabled = true;
    }
  }

  // update local reveal button text if present
  const localBtn = card.querySelector('.btnSmall');
  if(localBtn) localBtn.textContent = 'Hide Answer';
}

/**
 * Hide the reveal UI for a single card (restore to pre-reveal state).
 * This is disabled if the quiz has been confirmed (global revealed lock).
 */
function hideRevealForCard(uid, item, card){
  if(!card) return;
  // don't hide if Confirm has already been pressed (global lock)
  if(revealed) return;

  card.dataset.revealed = 'false';

  // MCQ: remove correct/wrong classes and restore pointer events
  if(item.type === 'mcq'){
    const opts = card.querySelectorAll('.opt');
    opts.forEach(optEl=>{
      optEl.classList.remove('correct','wrong');
      optEl.style.pointerEvents = ''; // allow clicking again
    });
  } else if(item.type === 'text'){
    // re-enable input
    const input = card.querySelector('.inputText');
    if(input){
      // remove result badge(s)
      card.querySelectorAll('.textResult').forEach(n=>n.remove());
      // remove reveal text block(s)
      card.querySelectorAll('.note.reveal-answer').forEach(n=>n.remove());
      input.disabled = false;
    }
  }

  const localBtn = card.querySelector('.btnSmall');
  if(localBtn) localBtn.textContent = 'Reveal Answer';
}

/**
 * Toggle reveal (call show or hide depending on card state).
 * Uses per-card data attribute .dataset.revealed (string 'true'/'false')
 */
function revealAnswerForCard(uid, item, card){
  if(!card) return;
  // If global Confirm lock is active, do nothing
  if(revealed) return;

  const isRevealed = card.dataset.revealed === 'true';
  if(isRevealed){
    hideRevealForCard(uid, item, card);
  } else {
    showRevealForCard(uid, item, card);
  }
}

/* Update renderBatch -> make sure the local reveal button calls the toggle function.
   In your renderBatch where you create `revealLocal` button, replace the previous handler
   with this one (or update the existing):

    revealLocal.addEventListener('click', ()=> revealAnswerForCard(uid, item, card));

   The global reveal button (revealBtn) can be wired to toggle all cards in the batch:
*/
revealBtn.onclick = ()=>{
  if(revealed) return; // lock after confirm
  const batch = batches[currentBatchIndex] || [];
  batch.forEach(it => {
    const uid = it._uid || `${it.number}`;
    const card = answersEl.querySelector(`.qcard[data-uid="${uid}"]`);
    if(card) revealAnswerForCard(uid, it, card);
  });
};

/* confirm/reveal logic — this counts for score and for building second-chance pool */
confirmBtn.addEventListener('click', ()=>{
  if(Object.keys(selections).length < batches[currentBatchIndex].length) return alert('Answer all slots before confirming.');
  revealed = true;
  let roundScore = 0;
  const batch = batches[currentBatchIndex];
  const batchWrong = [];

  batch.forEach(item => {
    const uid = item._uid || `${item.number}`;
    const card = answersEl.querySelector(`.qcard[data-uid="${uid}"]`);
    if(!card) return;

    if(item.type === 'text'){
      const input = card.querySelector('.inputText');
      const answer = (selections[uid]||'').toString().trim().toLowerCase();
      const correct = (item.correct||'').toString().trim();
      input.disabled = true;

      // remove prior
      card.querySelectorAll('.textResult').forEach(n=>n.remove());

      if(answer === correct.toLowerCase()){
        input.style.borderColor = '#1e693f';
        input.style.boxShadow = '0 6px 18px rgba(30,105,63,0.12)';
        roundScore++;
        play(sCorrect);
        const okBadge = document.createElement('span');
        okBadge.className = 'textResult badge correct';
        okBadge.textContent = 'Correct';
        input.insertAdjacentElement('afterend', okBadge);
      } else {
        input.style.borderColor = '#a32727';
        input.style.boxShadow = '0 6px 18px rgba(163,39,39,0.12)';
        play(sWrong);
        batchWrong.push(item);
        const wrongBadge = document.createElement('span');
        wrongBadge.className = 'textResult badge wrong';
        wrongBadge.textContent = 'Wrong';
        input.insertAdjacentElement('afterend', wrongBadge);
        const reveal = document.createElement('div');
        reveal.className = 'note';
        reveal.style.marginTop = '8px';
        reveal.innerHTML = `<strong>Answer: </strong><span class="badge">${correct}</span>`;
        card.appendChild(reveal);
      }

    } else if(item.type === 'mcq'){
      const chosen = selections[uid];
      const opts = card.querySelectorAll('.opt');
      opts.forEach(optEl=>{
        const letter = optEl.dataset.letter;
        if(letter === item.correct) optEl.classList.add('correct');
        if(letter === chosen && letter !== item.correct) optEl.classList.add('wrong');
        optEl.style.pointerEvents='none';
      });
      if(chosen === item.correct){
        roundScore++;
        play(sCorrect);
      } else {
        play(sWrong);
        batchWrong.push(item);
      }
    }
  });

  if(!secondChanceMode && batchWrong.length>0){
    mainWrongPool.push(...batchWrong);
  }

  accScore += roundScore;
  accScoreEl.textContent = accScore;

  // next or final / second chance trigger
  if(currentBatchIndex < batches.length - 1){
    nextBtnRound.style.display = 'inline-block';
  } else {
    if(!secondChanceMode){
      if(mainWrongPool.length > 0){
        setTimeout(()=> triggerSecondChanceAuto(mainWrongPool), 650);
      } else {
        showFinal();
      }
    } else {
      showFinal();
    }
  }
  confirmBtn.disabled = true;
});

/* second chance helpers (kept from your original flow) */
function dedupeByNumber(arr){
  const map = {};
  arr.forEach(it=> map[it.number] = it);
  return Object.values(map);
}
function playCinematicOverlay(onComplete){
  const overlay = document.createElement('div');
  overlay.id = 'cinematic-overlay';
  overlay.innerHTML = `
    <div class="cine-bar top" style="top:0;"></div>
    <div class="cine-bar bottom"></div>
    <div class="cine-title">SECOND CHANCE</div>
    <div class="cine-glow"></div>
  `;
  document.body.appendChild(overlay);
  const topBar = overlay.querySelector('.cine-bar.top');
  const bottomBar = overlay.querySelector('.cine-bar.bottom');
  const title = overlay.querySelector('.cine-title');
  topBar.style.animation = 'cine-bars-in .72s cubic-bezier(.2,.9,.2,1) forwards';
  bottomBar.style.animation = 'cine-bars-in-bottom .72s cubic-bezier(.2,.9,.2,1) forwards';
  title.style.animation = 'cine-title-in .85s cubic-bezier(.16,.9,.3,1) .18s forwards';
  const totalDuration = 1200;
  setTimeout(()=> {
    overlay.style.animation = 'cine-fadeout .38s ease forwards';
    setTimeout(()=> {
      overlay.remove();
      if(typeof onComplete === 'function') onComplete();
    }, 420);
  }, totalDuration);
}
function triggerSecondChanceAuto(wrongArr){
  const deduped = dedupeByNumber(wrongArr);
  if(deduped.length === 0) { showFinal(); return; }

  playCinematicOverlay(()=> {
    document.body.classList.add('second-chance');
    wrapEl.classList.add('second-chance','intro');
    setTimeout(()=> wrapEl.classList.remove('intro'), 900);

    secondChancePool = deduped.map(x => ({ ...x }));
    secondChanceMode = true;
    prepareFromPool(secondChancePool, true);

    finalBoxHolder.innerHTML = `<div class="finalBox reveal">
      <h3>Second Chance — Retry Wrong Questions 🔁</h3>
      <p class="small">You had <strong>${secondChancePool.length}</strong> missed question(s). Re-attempt them now.</p>
    </div>`;
    setTimeout(()=> renderBatch(), 700);
  });
}

/* next/retry/reshuffle buttons */
nextBtnRound.addEventListener('click', ()=>{
  currentBatchIndex++;
  renderBatch();
});
retrySameBtn.addEventListener('click', ()=> renderBatch());
reshuffleAllBtn.addEventListener('click', ()=>{
  if(secondChanceMode){
    prepareFromPool(secondChancePool, true);
    renderBatch();
  } else {
    prepareMain();
    renderBatch();
  }
});

/* final summary */
function showFinal(){
  if(!secondChanceMode){
    wrapEl.classList.remove('second-chance');
    document.body.classList.remove('second-chance');
  } else {
    wrapEl.classList.add('second-chance');
    document.body.classList.add('second-chance');
  }
  finalBoxHolder.innerHTML = `<div class="finalBox reveal">
    <h3>All rounds complete 🎉</h3>
    <p class="small">Total correct: <strong>${accScore}</strong> / ${POOL.length}</p>
    <div style="margin-top:10px; display:flex; gap:8px; justify-content:center">
      <button class="btnPrimary" id="restartSame">Restart (same order)</button>
      <button class="btnGhost" id="restartShuffle">Restart (reshuffle)</button>
    </div>
  </div>`;
  document.getElementById('restartSame').addEventListener('click', ()=>{
    secondChanceMode = false; mainWrongPool = [];
    wrapEl.classList.remove('second-chance'); document.body.classList.remove('second-chance');
    prepareFromPool(POOL, false); accScore = 0; accScoreEl.textContent = accScore; renderBatch();
  });
  document.getElementById('restartShuffle').addEventListener('click', ()=>{ prepareMain(); renderBatch(); });
}

/* boot */
function boot(){
  prepareMain();
  renderBatch();
}
boot();
</script>
</body>
</html>
