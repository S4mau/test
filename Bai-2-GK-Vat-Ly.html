<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image-backed Quiz — Multi-type Demo (Second Chance)</title>
<style>
:root{
  --bg:#071021; --card:#0f1724; --muted:#c8d0df; --accent:#ffb703;
  --ok:#1e693f; --bad:#a32727;
}
/* ---------- base (unchanged structure, verbose) ---------- */
*{box-sizing:border-box}
body{
  margin:0; min-height:100vh; font-family:Inter,system-ui,Arial;
  background:linear-gradient(180deg,#071021 0%,#1a1730 100%);
  color:var(--muted);
  display:flex; align-items:center; justify-content:center; padding:18px;
  transition: background .7s ease, color .45s ease;
}
.wrap{
  width:min(1100px,96vw);
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
  border-radius:12px; padding:14px;
  box-shadow:0 12px 40px rgba(2,6,23,0.6);
  border:1px solid rgba(255,255,255,0.03);
  transition: background .6s ease, box-shadow .6s ease, border-color .6s ease, color .45s ease, transform .45s;
}

/* header/viewer */
.header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px }
.header h1{ font-size:1.05rem; margin:0; color:#fff }
.header .stats{ display:flex; gap:10px; align-items:center }
.stat{ background:rgba(255,255,255,0.03); padding:6px 10px; border-radius:8px; font-weight:800; color:#fff }

/* viewer */
.viewer{ display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap }
.vbtn{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:800; transition: transform .12s, box-shadow .2s; }
.vbtn:hover{ transform: translateY(-3px) }
.imgWrap{
  width: 800px;
  max-width: 90vw;
  height: 500px;
  overflow: auto;
  background:#02030a;
  border-radius:10px;
  display:flex;
  align-items:flex-start;
  justify-content:flex-start;
  border: 1px solid var(--accent);
  transition: border-color .45s ease, box-shadow .45s ease, background .45s ease, transform .45s ease;
  will-change: transform;
}
.imgWrap img{ max-width: none; max-height: none; width: 100%; display:block; transition: transform .45s ease; }

/* responsive */
@media (max-width:880px){
 .answers{ grid-template-columns:1fr }
 .viewer{ flex-direction: column; }
 .imgWrap{ width: 100%; height: 350px; max-width: 100%; }
 .viewer-controls { width: 100%; justify-content: space-between; }
}
.viewer-controls { display:flex; gap:8px; align-items:center; }

/* answers */
.answers{ display:grid; grid-template-columns:repeat(2,1fr); gap:12px }
@media (max-width:880px){ .answers{ grid-template-columns:1fr } }
.qcard{
  background:var(--card); padding:12px; border-radius:10px;
  border:1px solid rgba(255,255,255,0.02);
  transition: background .45s, border-color .45s, box-shadow .45s, transform .45s;
}
.qcard:hover{ transform: translateY(-4px) }
.qhead{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; color:#eaf2ff; font-weight:800 }
.opts{ display:flex; gap:8px; flex-wrap:wrap }
.opt{ padding:8px 12px; border-radius:10px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.02); cursor:pointer; min-width:48px; text-align:center; font-weight:900; color:var(--muted); transition:transform .12s, background .35s, border-color .35s, box-shadow .35s; }
.opt:hover{ transform:translateY(-4px) }
.opt.selected{ outline:3px solid rgba(255,183,3,0.14); background:rgba(255,183,3,0.12); color:#fff }
.opt.correct{ background:var(--ok); color:#fff; box-shadow:0 6px 18px rgba(30,105,63,0.16) }
.opt.wrong{ background:var(--bad); color:#fff; box-shadow:0 6px 18px rgba(163,39,39,0.16) }
.inputText { width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:rgba(255,255,255,0.02); color:var(--muted) }

/* footer controls */
.controls{ display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:8px }
.btnPrimary{ background:linear-gradient(90deg,#ffb703,#ff9800); color:#111; font-weight:900; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; transition: transform .12s, box-shadow .25s; }
.btnPrimary:hover{ transform: translateY(-3px) }
.btnGhost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:8px 12px; border-radius:10px; cursor:pointer }
.small{ font-size:0.92rem; color:#97a0b6 }
.center{ display:flex; gap:8px; align-items:center }
.finalBox{ text-align:center; padding:16px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12)); border-radius:8px; margin-top:12px; transition: background .45s, border-color .45s }
.note{ font-size:0.9rem; color:#a9b3c7 }
.badge{ background:rgba(255,255,255,0.02); padding:6px 10px; border-radius:8px }

/* header visuals - we won't change header during Second Chance */
header { position: fixed; top: 0; left: 0; width: 100%; background: linear-gradient(90deg, #4d0d0d, #330044); color: white; padding: 15px 25px; display: flex; justify-content: space-between; align-items: center; font-size: 1.8em; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 9999; }

/* ---------- Second Chance (persisting) styles — NEW PALETTE (purple/amber) ---------- */
/* Use a night-friendly purple/dark-maroon palette (no blue/green) */
body.second-chance {
  background: linear-gradient(120deg,#0a0710 0%, #120417 35%, #0c0310 100%);
  color: #f6eefc;
  transition: background .9s ease, color .6s;
}

/* wrap — persist look */
.wrap.second-chance {
  background: linear-gradient(180deg, rgba(14,6,18,0.92), rgba(8,3,12,0.92));
  box-shadow:0 30px 80px rgba(8,2,12,0.82);
  border-color: rgba(191,70,172,0.06);
  color:#f6eefc;
}

/* override individual elements inside wrap so header unaffected */
.wrap.second-chance .qcard {
  background: linear-gradient(180deg, rgba(16,6,20,0.86), rgba(10,4,14,0.86));
  border-color: rgba(191,70,172,0.06);
  color:#f6eefc;
  box-shadow: 0 8px 28px rgba(6,6,10,0.55);
}
.wrap.second-chance .imgWrap {
  background: linear-gradient(180deg, rgba(12,5,18,0.95), rgba(8,3,12,0.95));
  border-color: rgba(191,70,172,0.12);
  box-shadow: inset 0 0 0 1px rgba(191,70,172,0.03);
  transform: scale(1.01);
}
.wrap.second-chance .imgWrap img {
  transform: scale(1.01);
  transition: transform .9s cubic-bezier(.2,.9,.2,1);
}

/* options look and micro-animations - purple/amber accent */
.wrap.second-chance .opts .opt {
  background: rgba(255,255,255,0.02);
  border-color: rgba(255,255,255,0.03);
  color: #f2e6fb;
}
.wrap.second-chance .opts .opt:hover { transform: translateY(-5px) scale(1.02); box-shadow: 0 10px 30px rgba(191,70,172,0.06); }
.wrap.second-chance .opts .opt.selected {
  outline-color: rgba(191,70,172,0.22);
  background: linear-gradient(90deg, rgba(191,70,172,0.08), rgba(255,184,92,0.04));
}
.wrap.second-chance .finalBox {
  background: linear-gradient(180deg, rgba(18,6,22,0.72), rgba(12,4,16,0.72));
  border: 1px solid rgba(191,70,172,0.07);
  color:#f6eefc;
}
.wrap.second-chance .stat, .wrap.second-chance .badge {
  background: rgba(191,70,172,0.05);
  color:#f8eefe;
}
.wrap.second-chance .btnGhost {
  border-color: rgba(255,255,255,0.03);
  color: #efe1fb;
}
.wrap.second-chance .btnPrimary {
  background: linear-gradient(90deg, #ffb86b, #d06cbf);
  color:#2b0b1e;
  box-shadow: 0 8px 28px rgba(176,70,130,0.12);
}

/* subtle persistent change for correct/wrong in second-chance (still green/red) */
/* make correct/wrong visibly green/red in second-chance mode */
.wrap.second-chance .opt.correct {
  background: var(--ok) !important;
  color: #fff !important;
  border-color: rgba(30,105,63,0.18);
  box-shadow: 0 6px 18px rgba(30,105,63,0.22);
}

.wrap.second-chance .opt.wrong {
  background: var(--bad) !important;
  color: #fff !important;
  border-color: rgba(163,39,39,0.18);
  box-shadow: 0 6px 18px rgba(163,39,39,0.22);
}

/* intro animation (short + smooth) */
.wrap.second-chance.intro {
  animation: secondChanceIntro .72s ease both;
}
@keyframes secondChanceIntro {
  0% { transform: scale(0.995) translateY(6px); opacity: 0; filter: blur(6px); }
  60% { transform: scale(1.02) translateY(-4px); opacity: 1; filter: blur(0); }
  100% { transform: scale(1) translateY(0); opacity: 1; filter: blur(0); }
}

/* small helper to fade in finalBox when auto-starting second chance */
.finalBox.reveal { animation: revealBox .42s ease both; }
@keyframes revealBox { from{ opacity:0; transform: translateY(8px)} to{ opacity:1; transform:none } }

/* lively micro-interactions: slight pulse on selected options */
@keyframes softPulse {
  0% { box-shadow: 0 0 0 rgba(0,0,0,0); }
  50% { box-shadow: 0 10px 30px rgba(191,70,172,0.06); }
  100% { box-shadow: 0 0 0 rgba(0,0,0,0); }
}
.wrap.second-chance .opt.selected { animation: softPulse 1.6s ease-in-out infinite; }

/* accessible focus styles */
.opt:focus { outline: 2px dashed rgba(255,255,255,0.06); outline-offset: 4px; }

/* ---------- Cinematic overlay for dramatic cutscene ---------- */
/* overlay sits above everything and plays an animation, then is removed */
#cinematic-overlay {
  position: fixed;
  inset: 0;
  z-index: 99999;
  pointer-events:none;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.0);
}
.cine-bar {
  position: absolute;
  left: 0;
  right: 0;
  height: 12vh;
  background: rgba(6,4,6,0.94);
  transform: translateY(-120%);
  will-change: transform, opacity;
}
.cine-bar.bottom { bottom: 0; top: auto; transform: translateY(120%); }
.cine-title {
  z-index: 100000;
  font-weight:900;
  font-family: Inter, system-ui, Arial;
  color: #fef6ff;
  text-shadow: 0 10px 30px rgba(0,0,0,0.6);
  font-size: clamp(28px, 6vw, 48px);
  letter-spacing: 0.08em;
  transform: scale(0.9) translateY(30px) skewX(-6deg);
  opacity: 0;
  will-change: transform, opacity;
}
/* light sweep across the title */
.cine-title:after{
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.25) 50%, rgba(255,255,255,0) 100%);
  transform: translateX(-120%);
  opacity: 0.7;
}

/* small cinematic particle/glow below title */
.cine-glow {
  position:absolute;
  width:60%;
  height:10px;
  bottom:40%;
  left:50%; transform:translateX(-50%);
  background: radial-gradient(closest-side, rgba(208,108,183,0.28), rgba(208,108,183,0));
  filter: blur(14px);
  opacity: 0;
}

/* keyframes */
@keyframes cine-bars-in {
  0% { transform: translateY(-120%); }
  60% { transform: translateY(6%); }
  100% { transform: translateY(0); }
}
@keyframes cine-bars-in-bottom {
  0% { transform: translateY(120%); }
  60% { transform: translateY(-6%); }
  100% { transform: translateY(0); }
}
@keyframes cine-title-in {
  0% { opacity:0; transform: scale(0.88) translateY(36px) skewX(-6deg); }
  60% { opacity:1; transform: scale(1.06) translateY(-8px) skewX(-2deg); }
  100% { opacity:1; transform: scale(1) translateY(0) skewX(0deg); }
}
@keyframes cine-light-sweep {
  0% { transform: translateX(-120%); }
  60% { transform: translateX(30%); }
  100% { transform: translateX(140%); }
}
@keyframes cine-glow {
  0% { opacity:0; transform: scaleX(0.8) }
  40% { opacity:1; transform: scaleX(1.05) }
  100% { opacity:0; transform: scaleX(1) }
}

/* helper to fade overlay out */
@keyframes cine-fadeout { from{ opacity:1 } to{ opacity:0 } }


.textResult.badge { margin-left: 8px; padding: 6px 8px; border-radius: 8px; font-weight: 800; }
.textResult.correct { background: #1e693f; color: #fff; }
.textResult.wrong   { background: #a32727; color: #fff; }
/* ...existing styles... */
</style>
</head>
<body>

<header> <!-- header intentionally outside wrap so it won't change during second chance -->
  <div style="font-size:0.95rem; font-weight:800; padding-left:6px">Your Quiz App (Header - stays same)</div>
  <div style="display:flex; gap:12px; align-items:center;">
    <a href="index.html" style="color:white; text-decoration:none; background:rgba(255,255,255,0.05); padding:6px 10px; border-radius:8px;">Menu</a>
  </div>
</header>

<div class="wrap" id="wrap">
  <div class="header">
    <h1>Image-backed Quiz — Mixed types (Second Chance)</h1>
    <div class="stats">
      <div class="stat">Round: <span id="roundIdx">1</span>/<span id="roundTotal">2</span></div>
      <div class="stat">Score: <span id="accScore">0</span> / <span id="poolTotal">20</span></div>
    </div>
  </div>

  <div class="viewer">
    <div class="viewer-controls">
      <button class="vbtn" id="prevBtn">◀ Prev</button>
    </div>
   <div class="imgWrap"><img id="viewerImg" src="assets/VatLy-Img/1-vl.png" alt="q-img" onerror="this.style.filter='grayscale(1)';"></div>
    <div class="viewer-controls">
      <button class="vbtn" id="nextBtn">Next ▶</button>
    </div>
    <div style="width:12px"></div>
    <div class="small" id="viewerIndex">Image 1 / 19</div>
  </div>

  <section>
    <div style="display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:10px">
      <div>
        <div class="note">Use Prev/Next to read the question images. Each answer slot below corresponds to a question number (image).</div>
        <div class="note">Question types: <strong>MCQ</strong> = single A–D, <strong>Multi</strong> = choose up to N true options, <strong>Text</strong> = type answer.</div>
      </div>
      <div style="display:flex; gap:8px">
        <button class="btnGhost" id="retrySame">Retry Round</button>
        <button class="btnGhost" id="reshuffleAll">Reshuffle All</button>
      </div>
    </div>

    <div class="answers" id="answers"></div>

    <div class="controls">
      <div class="small">Answered: <span id="selectedCount">0</span> / <span id="perRound">10</span></div>
      <div class="center">
        <button class="btnGhost" id="confirmBtn" disabled>Confirm Answers</button>
        <button class="btnPrimary" id="nextBtnRound" style="display:none">Next Round ▶</button>
      </div>
    </div>

    <div id="finalBoxHolder"></div>
  </section>
</div>


<audio id="sCorrect" src="assets/sounds/Correct-1.ogg" preload="auto"></audio>
<audio id="sWrong" src="assets/sounds/Incorrect-1.ogg" preload="auto"></audio>

<script>
/* ---------------- CONFIG / DEMO POOL ----------------
 - Put your images in assets/M-images/ and name them like: 1-M.jpg, 2-M.jpg, ... (or .png)
 - TOTAL_Q should equal the number of images you have (e.g. 34)
 - PER_ROUND determines how many answer slots per round (10)
 - Fill POOL with your real question numbers and correct answers.
*/
const TOTAL_Q = 19;
const PER_ROUND = 10;

const POOL = [
// BÀI 2 - P = I

{ number: 39, subject: 'C1-B2-PI', type: 'mcq', correct: 'D' },    { number: 51, subject: 'C13-B2-PI', type: 'mcq', correct: 'A' },
{ number: 40, subject: 'C2-B2-PI', type: 'mcq', correct: 'B' },    { number: 52, subject: 'C14-B2-PI', type: 'mcq', correct: 'A' },
{ number: 41, subject: 'C3-B2-PI', type: 'mcq', correct: 'B' },    { number: 53, subject: 'C15-B2-PI', type: 'mcq', correct: 'B' },
{ number: 42, subject: 'C4-B2-PI', type: 'mcq', correct: 'B' },    { number: 54, subject: 'C16-B2-PI', type: 'mcq', correct: 'B' },
{ number: 43, subject: 'C5-B2-PI', type: 'mcq', correct: 'A' },    { number: 55, subject: 'C17-B2-PI', type: 'mcq', correct: 'A' },
{ number: 44, subject: 'C6-B2-PI', type: 'mcq', correct: 'B' },    { number: 56, subject: 'C18-B2-PI', type: 'mcq', correct: 'D' },
{ number: 45, subject: 'C7-B2-PI', type: 'mcq', correct: 'B' },    { number: 57, subject: 'C19-B2-PI', type: 'mcq', correct: 'C' },
{ number: 46, subject: 'C8-B2-PI', type: 'mcq', correct: 'D' },    { number: 58, subject: 'C20-B2-PI', type: 'mcq', correct: 'D' },
{ number: 47, subject: 'C9-B2-PI', type: 'mcq', correct: 'D' },    { number: 59, subject: 'C21-B2-PI', type: 'mcq', correct: 'B' },
{ number: 48, subject: 'C10-B2-PI', type: 'mcq', correct: 'B' },   { number: 60, subject: 'C22-B2-PI', type: 'mcq', correct: 'D' },
{ number: 49, subject: 'C11-B2-PI', type: 'mcq', correct: 'D' },   { number: 61, subject: 'C23-B2-PI', type: 'mcq', correct: 'A' },
{ number: 50, subject: 'C12-B2-PI', type: 'mcq', correct: 'B' },   { number: 62, subject: 'C24-B2-PI', type: 'mcq', correct: 'A' },

// BÀI 2 - P = II
{ number: 63, subject: 'C25-B2-PII', type: 'multi', correct: ['A', 'D', 'B'] },   { number: 66, subject: 'C28-B2-PII', type: 'multi', correct: ['A'] },
{ number: 64, subject: 'C26-B2-PII', type: 'multi', correct: ['D', 'C'] },   { number: 67, subject: 'C29-B2-PII', type: 'multi', correct: ['A', 'D'] },
{ number: 65, subject: 'C27-B2-PII', type: 'multi', correct: ['B'] },   { number: 68, subject: 'C30-B2-PII', type: 'multi', correct: ['A','B', 'C'] },

// BÀI 2 - P = III
{ number: 69, subject: 'C31-B2-PIII', type: 'text', correct: '3' },    { number: 73, subject: 'C35-B2-PIII', type: 'text', correct: '1' },
{ number: 70, subject: 'C32-B2-PIII', type: 'text', correct: '288' },    { number: 74, subject: 'C36-B2-PIII', type: 'text', correct: '1' },
{ number: 71, subject: 'C33-B2-PIII', type: 'text', correct: '1245' },    { number: 75, subject: 'C37-B2-PIII', type: 'text', correct: '17' },
{ number: 72, subject: 'C34-B2-PIII', type: 'text', correct: '1345' },    { number: 76, subject: 'C38-B2-PIII', type: 'text', correct: '0,05' },
//bo 5
];

// 👇 This goes OUTSIDE the array
POOL.forEach(q => q._uid = `${q.subject || 'General'}-${q.number}`);
/* ---------------- state ---------------- */
let shuffled = [];
let batches = [];
let currentBatchIndex = 0;
let selections = {}; // map number -> selected (string for mcq/text, array for multi)
let revealed = false;
let accScore = 0;
let viewIndex = 1;

/* Second Chance (auto) state */
let secondChanceMode = false;
let mainWrongPool = [];  // collect wrong items during main run
let secondChancePool = []; // pool of wrong items for second chance

/* ---------------- DOM ---------------- */
const answersEl = document.getElementById('answers');
const viewerImg = document.getElementById('viewerImg');
const viewerIndex = document.getElementById('viewerIndex');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const selectedCountEl = document.getElementById('selectedCount');
const confirmBtn = document.getElementById('confirmBtn');
const nextBtnRound = document.getElementById('nextBtnRound');
const retrySameBtn = document.getElementById('retrySame');
const reshuffleAllBtn = document.getElementById('reshuffleAll');
const roundIdxEl = document.getElementById('roundIdx');
const roundTotalEl = document.getElementById('roundTotal');
const accScoreEl = document.getElementById('accScore');
const poolTotalEl = document.getElementById('poolTotal');
const perRoundEl = document.getElementById('perRound');
const finalBoxHolder = document.getElementById('finalBoxHolder');
const wrapEl = document.getElementById('wrap');

const sClick = document.getElementById('sClick');
const sCorrect = document.getElementById('sCorrect');
const sWrong = document.getElementById('sWrong');

function play(el){ try{ el.currentTime=0; el.play(); }catch(e){} }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ---------------- pool/batch helpers ---------------- */
// Prepare batches from any pool array. Keeps poolTotal display referencing the original POOL.length.
function prepareFromPool(poolArr, reshuffle=true){
  poolTotalEl.textContent = POOL.length;
  shuffled = [...poolArr];
  if(reshuffle) shuffle(shuffled);
  batches = [];
  for(let i=0;i<shuffled.length;i+=PER_ROUND) batches.push(shuffled.slice(i, i+PER_ROUND));
  roundTotalEl.textContent = batches.length;
  currentBatchIndex = 0;
}

/* initial prepare for main run */
function prepareMain(){
  accScore = 0;
  accScoreEl.textContent = accScore;
  mainWrongPool = [];
  secondChanceMode = false;
  // make sure any visual second-chance class is removed
  wrapEl.classList.remove('second-chance','intro');
  document.body.classList.remove('second-chance');
  prepareFromPool(POOL, true);
}

/* ---------------- viewer ---------------- */
function updateViewer(){
  // load images from VatLy-Img named like: 1-vl.png, 2-vl.png, ...
  viewerImg.src = `assets/VatLy-Img/${viewIndex}-vl.png`;
  viewerIndex.textContent = `Image ${viewIndex} / ${TOTAL_Q}`;
}

viewerImg.onerror = function(){
  // if png missing try jpg variant, otherwise show grayscale
  if(viewerImg.src && viewerImg.src.endsWith('.png')) {
    viewerImg.src = viewerImg.src.replace('.png', '.jpg');
    return;
  }
  // final fallback: keep the grayscale filter (no more attempts)
  this.style.filter = 'grayscale(1)';
};

function attachViewer(){
  prevBtn.addEventListener('click', ()=>{ viewIndex = Math.max(1, viewIndex-1); updateViewer(); });
  nextBtn.addEventListener('click', ()=>{ viewIndex = Math.min(TOTAL_Q, viewIndex+1); updateViewer(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='ArrowLeft'){ viewIndex=Math.max(1,viewIndex-1); updateViewer(); } if(e.key==='ArrowRight'){ viewIndex=Math.min(TOTAL_Q,viewIndex+1); updateViewer(); }});
}

/* ---------------- render batch ---------------- */
/* ---------- Replace renderBatch() with this version ---------- */
function renderBatch(){
  finalBoxHolder.innerHTML = '';
  revealed = false;
  selections = {};
  answersEl.innerHTML = '';

  // safety
  if(!batches || batches.length===0){
    finalBoxHolder.innerHTML = `<div class="finalBox"><h3>No questions in this pool.</h3></div>`;
    return;
  }

  const batch = batches[currentBatchIndex];
  roundIdxEl.textContent = currentBatchIndex+1;
  perRoundEl.textContent = batch.length;

  // set viewer to first question of this batch for convenience
  if(batch[0] && batch[0].number){ viewIndex = batch[0].number; updateViewer(); }

  batch.forEach(item=>{
    // make sure we have a stable uid on each item (you already add _uid when building POOL)
    const uid = item._uid || `${item.subject || 'General'}-${item.number}`;

    const card = document.createElement('div');
    card.className = 'qcard';
    card.dataset.num = item.number;
    card.dataset.uid = uid;

    const typeLabel = item.type === 'mcq' ? 'MCQ' : item.type === 'multi' ? `Multi (max ${item.maxSelect})` : 'Text';
    card.innerHTML = `<div class="qhead"><div>Q${item.number}${item.subject ? ' - ' + item.subject : ''}</div><div class="small">${typeLabel}</div></div>`;

    if(item.type === 'text'){
      const input = document.createElement('input');
      input.className = 'inputText';
      input.placeholder = 'Type answer...';
      // store selections by uid (not by number)
      input.addEventListener('input', ()=> {
        if(revealed) return;
        const val = input.value.trim();
        if(val.length>0) selections[uid] = val;
        else delete selections[uid];
        updateSelectionState();
      });
      card.appendChild(input);
    } else {
      const opts = document.createElement('div');
      opts.className = 'opts';
      ['A','B','C','D'].forEach(opt=>{
        const b = document.createElement('div');
        b.className = 'opt';
        b.tabIndex = 0;
        b.textContent = opt;
        b.addEventListener('click', ()=>{
          if(revealed) return;
          if(item.type === 'mcq'){
            Array.from(opts.children).forEach(ch=> ch.classList.remove('selected'));
            b.classList.add('selected');
            selections[uid] = opt;           // <- keyed by uid
            play(sClick);
          } else if(item.type === 'multi'){
            const already = b.classList.contains('selected');
            if(!already){
              const cur = (selections[uid] || []);
              if(cur.length >= (item.maxSelect||3)) {
                b.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:220});
                return;
              }
              b.classList.add('selected');
              selections[uid] = [...(selections[uid] || []), opt];
            } else {
              b.classList.remove('selected');
              selections[uid] = (selections[uid] || []).filter(x=>x!==opt);
              if(selections[uid].length===0) delete selections[uid];
            }
            play(sClick);
          }
          updateSelectionState();
        });
        // keyboard accessibility
        b.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); b.click(); } });
        opts.appendChild(b);
      });
      card.appendChild(opts);
    }
    answersEl.appendChild(card);
  });

  updateSelectionState();
  nextBtnRound.style.display='none';
  confirmBtn.disabled = true;
}


/* ---------------- update state ---------------- */
function updateSelectionState(){
  const answered = Object.keys(selections).length;
  selectedCountEl.textContent = answered;
  const need = batches[currentBatchIndex].length;
  confirmBtn.disabled = (answered < need) || revealed;
}

/* ---------------- confirm/reveal logic ---------------- */
/* ---------- Replace the confirm/reveal handler with this version ---------- */
confirmBtn.addEventListener('click', ()=>{
  // count selections against current batch length
  if(Object.keys(selections).length < batches[currentBatchIndex].length) return alert('Answer all slots before confirming.');
  revealed = true;
  let roundScore = 0;
  const batch = batches[currentBatchIndex];

  // collect wrongs for this batch (to later build mainWrongPool)
  const batchWrong = [];

  batch.forEach(item=>{
    const uid = item._uid || `${item.subject || 'General'}-${item.number}`;
    const card = answersEl.querySelector(`.qcard[data-uid="${uid}"]`);
    if(!card) return;

    // ---- TEXT ----
    if(item.type === 'text'){
      const input = card.querySelector('.inputText');
      const answer = (selections[uid]||'').toString().trim().toLowerCase();
      const correct = (item.correct||'').toString().trim();
      const correctLower = correct.toLowerCase();
      input.disabled = true;

      // remove any prior result node
      card.querySelectorAll('.textResult').forEach(n=>n.remove());

      if(answer === correctLower){
        // correct
        input.style.borderColor = '#1e693f';
        input.style.boxShadow = '0 6px 18px rgba(30,105,63,0.12)';
        roundScore++;
        play(sCorrect);

        // add a small 'Correct' badge next to the input for instant clarity
        const okBadge = document.createElement('span');
        okBadge.className = 'textResult badge correct';
        okBadge.textContent = 'Correct';
        input.insertAdjacentElement('afterend', okBadge);

      } else {
        // wrong: style input, play sound, add to wrong pool
        input.style.borderColor = '#a32727';
        input.style.boxShadow = '0 6px 18px rgba(163,39,39,0.12)';
        play(sWrong);
        batchWrong.push(item);

        // add a 'Wrong' badge
        const wrongBadge = document.createElement('span');
        wrongBadge.className = 'textResult badge wrong';
        wrongBadge.textContent = 'Wrong';
        input.insertAdjacentElement('afterend', wrongBadge);

        // reveal correct answer under the input (keeps your existing UX)
        const reveal = document.createElement('div');
        reveal.className = 'note';
        reveal.style.marginTop = '8px';
        const label = document.createElement('strong');
        label.textContent = 'Answer: ';
        const val = document.createElement('span');
        val.className = 'badge';
        val.textContent = correct;
        reveal.appendChild(label);
        reveal.appendChild(val);
        card.appendChild(reveal);
      }

    // ---- MCQ ----
    } else if(item.type === 'mcq'){
      const chosen = selections[uid];
      const opts = card.querySelectorAll('.opt');
      opts.forEach(optEl=>{
        const v = optEl.textContent;
        if(v === item.correct) optEl.classList.add('correct');
        if(v === chosen && v !== item.correct) optEl.classList.add('wrong');
        optEl.style.pointerEvents='none';
      });
      if(chosen === item.correct){
        roundScore++;
        play(sCorrect);
      } else {
        play(sWrong);
        batchWrong.push(item);
      }

    // ---- MULTI ----
    } else if(item.type === 'multi'){
      const chosen = selections[uid] ? [...selections[uid]] : [];
      const correctSet = (item.correct||[]).slice().sort();
      const chosenSet = chosen.slice().sort();
      const opts = card.querySelectorAll('.opt');
      opts.forEach(optEl=>{
        const v = optEl.textContent;
        const isChosen = chosen.includes(v);
        const isCorrect = item.correct.includes(v);
        if(isCorrect) optEl.classList.add('correct');
        if(isChosen && !isCorrect) optEl.classList.add('wrong');
        optEl.style.pointerEvents='none';
      });
      const eq = (a,b) => a.length===b.length && a.every((v,i)=>v===b[i]);
      if(eq(correctSet, chosenSet)){
        roundScore++;
        play(sCorrect);
      } else {
        play(sWrong);
        batchWrong.push(item);
      }
    }
  });

  // If main run (not second chance) collect wrongs for second-chance pool
  if(!secondChanceMode && batchWrong.length>0){
    mainWrongPool.push(...batchWrong);
  }

  accScore += roundScore;
  accScoreEl.textContent = accScore;

  if(currentBatchIndex < batches.length - 1){
    nextBtnRound.style.display='inline-block';
  } else {
    // End of current pool
    if(!secondChanceMode){
      // Main run finished — auto start second chance if there are wrongs
      if(mainWrongPool.length > 0){
        // small delay so user sees final reveal, then auto trigger second chance
        setTimeout(()=> {
          triggerSecondChanceAuto(mainWrongPool);
        }, 650);
      } else {
        // no wrongs — final screen
        showFinal();
      }
    } else {
      // was second chance pool end
      showFinal(); // final summary
    }
  }

  confirmBtn.disabled = true;
});


/* ---------------- second chance flow ---------------- */
/* dedupe by question number */
function dedupeByNumber(arr){
  const map = {};
  arr.forEach(it=> map[it.number] = it);
  return Object.values(map);
}

/* Create cinematic overlay DOM, play animation, then call `onComplete` */
function playCinematicOverlay(onComplete){
  // build overlay
  const overlay = document.createElement('div');
  overlay.id = 'cinematic-overlay';
  overlay.innerHTML = `
    <div class="cine-bar top" style="top:0;"></div>
    <div class="cine-bar bottom"></div>
    <div class="cine-title">SECOND CHANCE</div>
    <div class="cine-glow"></div>
  `;
  document.body.appendChild(overlay);

  const topBar = overlay.querySelector('.cine-bar.top');
  const bottomBar = overlay.querySelector('.cine-bar.bottom');
  const title = overlay.querySelector('.cine-title');
  const glow = overlay.querySelector('.cine-glow');

  // animate bars in
  topBar.style.animation = 'cine-bars-in .72s cubic-bezier(.2,.9,.2,1) forwards';
  bottomBar.style.animation = 'cine-bars-in-bottom .72s cubic-bezier(.2,.9,.2,1) forwards';
  title.style.animation = 'cine-title-in .85s cubic-bezier(.16,.9,.3,1) .18s forwards';
  glow.style.animation = 'cine-glow .95s ease .18s forwards';
  // start a light sweep after a bit (manually animate pseudo via setting :after via class)
  setTimeout(()=> {
    title.style.setProperty('--light','1');
    // animate the pseudo by adding a tiny style element that animates :after
    const lightSweep = document.createElement('style');
    lightSweep.id = 'cine-sweep-style';
    lightSweep.textContent = `
      #cinematic-overlay .cine-title:after{
        animation: cine-light-sweep 0.9s cubic-bezier(.2,.9,.2,1) .36s forwards;
      }
    `;
    document.head.appendChild(lightSweep);
  }, 300);

  // total cinematic duration — keep it long-ish but not annoying (1.6s visible + fade)
  const totalDuration = 1600;
  setTimeout(()=> {
    // fade overlay out smoothly
    overlay.style.animation = 'cine-fadeout .38s ease forwards';
    // after fade remove overlay and call onComplete
    setTimeout(()=>{
      try{ document.getElementById('cine-sweep-style')?.remove(); }catch(e){}
      overlay.remove();
      if(typeof onComplete === 'function') onComplete();
    }, 420);
  }, totalDuration);
}

/* Triggered automatically at end of main run */
function triggerSecondChanceAuto(wrongArr){
  const deduped = dedupeByNumber(wrongArr);
  if(deduped.length === 0) { showFinal(); return; }

  // play cinematic overlay then set second-chance visuals + load pool
  playCinematicOverlay(()=> {
    // Persist theme: add the classes to body and wrap
    document.body.classList.add('second-chance');
    wrapEl.classList.add('second-chance','intro');

    // remove the intro class after the intro animation so only persistent styles remain
    setTimeout(()=> wrapEl.classList.remove('intro'), 900);

    // Prepare second chance pool from deduped items
    secondChancePool = deduped.map(x => ({ ...x }));
    secondChanceMode = true;
    // prepare batches from secondChancePool (reshuffle to mix)
    prepareFromPool(secondChancePool, true);

    // show an intermediate finalBox that explains second chance then auto start
    finalBoxHolder.innerHTML = `<div class="finalBox reveal">
      <h3>Second Chance — Retry Wrong Questions 🔁</h3>
      <p class="small">You had <strong>${secondChancePool.length}</strong> missed question(s). Re-attempt them now.</p>
      <p class="small" style="margin-top:8px">The UI changed to Second Chance mode (night-friendly theme). Good luck!</p>
    </div>`;
    // small pause so user reads message then render first batch
    setTimeout(()=> {
      renderBatch();
    }, 700);
  });
}

/* ---------------- next / retry / reshuffle ---------------- */
nextBtnRound.addEventListener('click', ()=>{
  currentBatchIndex++;
  renderBatch();
});
retrySameBtn.addEventListener('click', ()=> renderBatch());
reshuffleAllBtn.addEventListener('click', ()=>{
  if(secondChanceMode){
    // reshuffle second chance pool
    prepareFromPool(secondChancePool, true);
    renderBatch();
  } else {
    // full restart main
    prepareMain();
    renderBatch();
    viewIndex = 1; updateViewer();
  }
});

/* ---------------- final summary ---------------- */
function showFinal(){
  // if the user never entered second chance, remove body/wrap second-chance class
  if(!secondChanceMode){
    wrapEl.classList.remove('second-chance');
    document.body.classList.remove('second-chance');
  } else {
    // if they completed second-chance, keep the second-chance visuals (user asked to stay)
    wrapEl.classList.add('second-chance');
    document.body.classList.add('second-chance');
  }

  finalBoxHolder.innerHTML = `<div class="finalBox reveal">
    <h3>All rounds complete 🎉</h3>
    <p class="small">Total correct: <strong>${accScore}</strong> / ${POOL.length}</p>
    <div style="margin-top:10px; display:flex; gap:8px; justify-content:center">
      <button class="btnPrimary" id="restartSame">Restart (same order)</button>
      <button class="btnGhost" id="restartShuffle">Restart (reshuffle)</button>
    </div>
  </div>`;
  document.getElementById('restartSame').addEventListener('click', ()=>{
    // restart full original pool same order — clear second-chance visuals on restart
    secondChanceMode = false;
    mainWrongPool = [];
    wrapEl.classList.remove('second-chance');
    document.body.classList.remove('second-chance');
    prepareFromPool(POOL, false);
    accScore = 0; accScoreEl.textContent = accScore;
    renderBatch();
  });
  document.getElementById('restartShuffle').addEventListener('click', ()=>{
    prepareMain();
    renderBatch();
  });
}

/* ---------------- boot ---------------- */
function boot(){
  prepareMain();
  attachViewer();
  renderBatch();
  updateViewer();
}
boot();


</script>
</body>
</html>
